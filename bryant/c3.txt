Practice Problems

--------------------------------------------------------------------------------

3.1)

Address Value   Register    Value
0x100   0xFF    %rax        0x100
0x104   0xAB    %rcx        0x1
0x108   0x13    %rdx        0x3
0x10C   0x11

Operand         Value
%rax            0x100
0x104           0xAB
$0x108          0x108
(%rax)          0xFF
4(%rax)         0xAB
9(%rax, %rdx)   0x11
260(%rcx, %rdx) 0x13
0xFC(, %rcx, 4) 0xFF
(%rax, %rdx, 4) 0x11

--------------------------------------------------------------------------------

3.2)

movl %eax, (%rsp)
movw (%rax), %dx
movb $0xFF, %bl
movb (%rsp, %rdx, 4), %dl
movq (%rdx), %rax
movw %dx, (%rax)

--------------------------------------------------------------------------------

3.3)

movb $0xF, (%ebx) # %ebx cannot be used as address register
movl %rax, (%rsp) # Mismatch between instruction suffix and register ID
movw (%rax), 4(%rsp) # Source and destination are memory addresses at the same time
movb %al, %sl # No register named %sl
movq %rax, $0x123 # Destination cannot be a literal
movl %eax, %rdx # Destination operand incorrect size
movb %si, 8(%rbp) # Mismatch between instruction suffix and register ID

--------------------------------------------------------------------------------

3.4)

# sp in %rdi, dp in %rsi

# long - long
movq (%rdi), %rax # Read 8 bytes
movq %rax, (%rsi) # Store 8 bytes

# char - int 
movsbl (%rdi), %eax # Convert char to int
movl %eax, (%rsi) # Store 4 bytes

# char - unsigned
movsbl (%rdi), %eax # Convert char to int
movl %eax, (%rsi) # Store 4 bytes

# unsigned char - long
movzbl (%rdi), %eax # Read byte and zero-extend
movq %rax, (%rsi) # Store 8 bytes

# int - char
movl (%rdi), %eax # Read 4 bytes
movb %al, (%rsi) # Store low-order byte

# unsigned - unsigned char
movl (%rdi), %eax # Read 4 bytes
movb %al, (%rsi) # Store low-order byte

char - short
movsbw (%rdi), %ax # Read byte and sign-extend
movw %ax, (%rsi) # Store 2 bytes

--------------------------------------------------------------------------------

3.5)

# xp in %rdi, yp in %rsi, zp in %rdx

decode1:
    movq (%rdi), %r8
    movq (%rsi), %rcx
    movq (%rdx), %rax
    movq %r8, (%rsi)
    movq %rcx, (%rdx)
    movq %rax, (%rdi)
    ret
    
void decode1(long *xp, long *yp, long *zp) {    
    long r8 = *xp;
    long c = *yp;
    long a = *zp;
    
    *yp = r8;
    *zp = c;
    *xp = a;
}

--------------------------------------------------------------------------------

3.6)

# %rax holds x, %rcx holds y

Instruction                 Result
leaq 6(%rax), %rdx          x + 6
leaq (%rax, %rcx), %rdx     x + y
leaq (%rax, %rcx, 4), %rdx  x + 4 * y
leaq 7(%rax, %rax, 8), %rdx 9 * x + 7
leaq 0xA(, %rcx, 4), %rdx   4 * y + 10
leaq 9(%rax, %rcx, 2), %rdx x + 2 * y + 9

--------------------------------------------------------------------------------

3.7)

# x in %rdi, y in %rsi, z in %rdx

scale2:
    leaq (%rdi, %rdi, 4), %rax
    leaq (%rax, %rsi, 2), %rax
    leaq (%rax, %rdx, 8), %rax
    ret
    
long scale2(long x, long y, long z) {    
    long t = 5 * x + 2 * y + 8 * z;
    
    return t;
}

--------------------------------------------------------------------------------

3.8)

Address Value   Register    Value
0x100   0xFF    %rax        0x100
0x108   0xAB    %rcx        0x1
0x110   0x13    %rdx        0x3
0x118   0x11

Instruction                 Destination     Value
addq %rcx, (%rax)           0x100           0x10
subq %rdx, 8(%rax)          0x108           0xA8
imulq $16, (%rax, %rdx, 8)  0x118           0x110
incq 16(%rax)               0x110           0x14
decq %rcx                   %rcx            0x0
subq %rdx, %rax             %rax            0xFD

--------------------------------------------------------------------------------
  
3.9)

long shift_left4_rightn(long x, long n) {
    x <<= 4;
    x >>= n;
    
    return n;
}

# x in %rdi, n in %rsi

shift_left4_rightn:
    movq %rdi, %rax # Get x
    salq $4, %rax # x <<= 4
    movl %esi, %ecx # Get n (4 bytes)
    sarq %cl, %rax # x >>= n
    
--------------------------------------------------------------------------------
    
3.10)

# x in %rdi, y in %rsi, z in %rdx

arith2:
    orq %rsi, %rdi
    sarq $3, %rdi
    notq %rdi
    movq %rdx, %rax
    subq %rdi, %rax
    ret
    
long arith2(long x, long y, long z) {
    long t1 = x | y;
    long t2 = t1 >> 3;
    long t3 = ~t2;
    long t4 = z - t3;
    
    return t4;
}

--------------------------------------------------------------------------------

3.11) 

xorq %rdx, %rdx

a) This clears the %rdx register, so %rdx = 0x0000000000000000. In C, x = 0
b) movq $0, %rdx
c) xorq requires 3 bytes, movq requires 7 bytes

--------------------------------------------------------------------------------

3.12)

void uremdiv(unsigned long x, unsigned long y, unsigned long *qp, unsigned long *rp) {
    unsigned long q = x / y;
    unsigned long r = x % y;
    *qp = q;
    *rp = r;
}

# x in %rdi, y in %rsi, qp in %rdx, rp in %rcx

uremdiv:
    movq %rdx, %r8 # Copy qp
    movq %rdi, %rax # Move x to lower 8 bytes of dividend
    xorq %rdx, %rdx # Set %rdx to zero
    divq %rsi # Divide by y
    movq %rax, (%r8) # Store quotient at qp
    movq %rdx, (%rcx) # Store remainder at rp
    ret
    
--------------------------------------------------------------------------------

3.13)

A) data_t: int; COMP: <
B) data_t: short; COMP: >=
C) data_t: unsigned char; COMP: <=
D) data_t: long, unsigned long; *, COMP: !=

--------------------------------------------------------------------------------

3.14)

A) data_t: long; COMP: >=
B) data_t: short, unsigned short; COMP: ==
C) data_t: unsigned char; COMP: >
D) data_t: int; COMP: <=

--------------------------------------------------------------------------------

3.15)

a)
4003fa: 74 02       je 4003fe
4003fc: ff d0       callq *%rax

b)
40042f: 74 f4       je 400425
400431: 5d          pop %rbp

c)
400543: 77 02       ja 400547
400545: 5d          pop %rbp

d)
4005e8: e9 73 ff ff ff ff       jmpq 400560
4005ed: 90                      nop

--------------------------------------------------------------------------------

3.16)

void cond(long a, long *p) {
    if (p && a > *p) {
        *p = a;
    }
}

# a in %rdi, p in %rsi

cond:
    testq %rsi, %rsi # p != 0
    je .L1 # p == 0, go to .L1
    cmpq %rdi, (%rsi) # *p < a
    jge .L1 # p >= a, go to .L1
    movq %rdi, (%rsi) # *p = a
.L1:
    rep
    ret
    
a)
    
void cond(long a, long *p){
    if (p == 0) {
        goto exit;
    }
    
    if (*p >= a) {
        goto exit;
    }
    
    *p = a;
    
    exit:
        return;
}

b)

The first conditional branch is part of the implementation of the && expression. If the test for p being non-null fails, the code will skip the test of a > *p.

--------------------------------------------------------------------------------

3.17)

a)

long absdiff_se(lonx, long y) {
    long result;
    
    if (x < y) {
        goto x_lt_y;
    }
    
    ge_cnt++;
    result = x - y;
    
    goto res;
    
    x_lt_y:
        lt_cnt++;
        result = y - x;
    
    res: 
        return result;
}

b)

t = test-expr;
if (!t)
    goto done;
then-statement
done:

--------------------------------------------------------------------------------

3.18)

# x in %rdi, y in %rsi, z in %rdx

test:
    leaq (%rdi, %rsi), %rax
    addq %rdx, %rax
    cmpq $-3, %rdi
    jge .L2
    cmpq %rdx, %rsi
    jge .L3
    movq %rdi, %rax
    imulq %rsi, %rax
    ret
.L3:
    movq %rsi, %rax
    imulq %rdx, %rax
    ret
.L2:
    cmpq $2, %rdi
    jle .L4
    movq %rdi, %rax
    imulq %rdx, %rax
.L4:
    rep
    ret
    
long test(long x, long y, long z) {
    long val = x + y + z;
    
    if (x < -3) {
        if (y < z) {
            val = x * y;
        } else {
            val = y * z;
        }
    } else if (x > 2) {
        val = x * z;
    }
    
    return val;
}

--------------------------------------------------------------------------------

3.19)

a)

We have T_MP = 2 * (T_ran - T_OK), with T_ran = 31 and T_OK = 16.
So, T_MP = 2 * (31 - 16) = 2 * 15 = 30

b)

T_OK + T_MP = 30 + 16 = 46

--------------------------------------------------------------------------------

3.20)

a, b)

#define OP /

long arith(long x) {
    return x OP 8;
}

# x in %rdi

arith:
    leaq 7(%rdi), %rax # y = x + 7
    testq %rdi, %rdi # Test x
    cmovns %rdi, %rax # if x >= 0, then y = x
    sarq $3, %rax # y = y >> 3
    ret
    
--------------------------------------------------------------------------------

3.21)

long test(long x, long y) {
    long val = x * 8;
    
    if (y > 0) {
        if (x < y) {
            val = y - x;
        } else {
            val = x & y;
        }
    } else if (y <= -2) {
        val = x + y;
    }
    
    return val;
    
# x in %rdi, y in %rsi

test:
    leaq 0(, %rdi, 8), %rax
    testq %rsi, %rsi
    jle .L2
    movq %rsi, %rax
    subq %rdi, %rax
    movq %rdi, %rdx
    andq %rsi, %rdx
    cmpq %rsi, %rdi
    cmovge %rdx, %rax
    ret
.L2:
    addq %rsi, %rdi
    cmpq $-2, %rsi
    cmovle %rdi, %rax
    ret

--------------------------------------------------------------------------------

3.22)

a)

n = 12

b)

n = 20

--------------------------------------------------------------------------------

3.23)

a)

x in %rdi, y in %rcx, n in %rdx

b)

leaq 1(%rcx, %rax), %rax

c)

dw_loop:
    movq %rdi, %rax # Copy x to %rax
    movq %rdi, %rcx # y = x
    imulq %rdi, %rcx # y = x * x
    leaq (%rdi, %rdi), %rdx # n = x + x
.L2:
    leaq 1(%rcx, %rax), %rax # x = x + y + 1
    subq $1, %rdx # n = n - 1
    testq %rdx, %rdx # Test n
    jg .L2 # if n > 0, go to .L2
    rep
    ret
    
--------------------------------------------------------------------------------

3.24)

long loop_while(long a, long b) {
    long result = 1;
    
    while (a < b) {
        result = result * (a + b);
        a = a + 1;
    }
    
    return result;
}

# a in %rdi, b in %rsi

loop_while:
    movl $1, %eax
    jmp .L2
.L3:
    leaq (%rdi, %rsi), %rdx
    imulq %rdx, %rax
    addq $1, %rdi
.L2:
    cmpq %rsi, %rdi
    jl .L3
    rep
    ret
    
--------------------------------------------------------------------------------

3.25)

long loop_while2(long a, long b) {
    long result = b;
    
    while (b > 0) {
        result = result * a;
        b = b - a;
    }
    
    return result;
}

# a in %rdi, b in %rsi

loop_while:
    testq %rsi, %rsi
    jle .L8
    movq %rsi, %rax
.L7:
    imulq %rdi, %rax
    subq %rdi, %rsi
    testq %rsi, %rsi
    jg .L7
    rep
    ret
.L8:
    movq %rsi, %rax
    ret
    
--------------------------------------------------------------------------------

3.26)

a)

It uses the jump-to-middle translation, using the jmp instruction

b)

long fun_a(unisgned long x) {
    long val = 0;
    
    while (x != 0) {
        val = val ^ x;
        x = x >> 1;
    }
    
    val = val & 1;
    
    return val;
}

# x in %rdi

fun_a:
    movl $0, eax
    jmp .L5
.L6:
    xorq %rdi, %rax
    shrq %rdi # Shift right by 1
.L5:
    testq %rdi, %rdi
    jne .L6
    andl $1, %eax
    ret
    
c)

It computes the parity of argument x. That is, it returns 1 if there is an odd number
of ones in x and O if there is an even number.

--------------------------------------------------------------------------------

3.27)

long fact_for(long n) {
    long i = 2;
    long result = 1;
    
    if (n <= 1) {
        goto done;
    }
    
    loop:
        result *= i;
        i++;
        
        if (i <= n) {
            goto loop;
        }
    
    done:
        return result;
}

--------------------------------------------------------------------------------

3.28)

# x in %rdi

fun_b:
    movl $64, %edx
    movl $0, %eax
.L10:
    movq %rdi, %rcx
    andl $1, %ecx
    addq %rax, %rax
    orq %rcx, %rax
    shrq %rdi # Shift right by 1
    subq $1, %rdx
    jne .L10
    rep
    ret
    
a)

long fun_b(unsigned long x) {
    long val = 0;
    long i;
    
    for (i = 64; i >= 0; i--) {
        val = (val << 1) | (x & 1);
        x = x >> 1; 
    }
    
    return val;
}

b)

The code was generated using the guarded-do transformation, but the com­ piler detected that,
since i is initialized to 64, it will satisfy the test i != 0, and therefore the initial test 
is not required.

c)

This code reverses the bits in x, creating a mirror image. It does this by shifting the 
bits of x from left to right, and then filling these bits in as it shifts val from right to 
left.

--------------------------------------------------------------------------------

3.29)

a)

This code has an infinite loop, since the continue statement would prevent index variable 
i from being updated.

b)

/* Sum even numbers between O and 9 */

long sum = O;
long i = 0;

while (i < 10) {
    if (i & 1) {
        goto update;
    }

    sum + = i;
    
    update:
        i++;
}

--------------------------------------------------------------------------------

3.30)

# x in %rdi

switch2:
    addq $1, %rdi
    cmpq $8, %rdi
    ja .L2
    jmp *.L4(, %rdi, 8)
    
.L4:
    .quad .L9
    .quad .L5
    .quad .L6
    .quad .L7
    .quad .L2
    .quad .L7
    .quad .L8
    .quad .L2
    .quad .L5
    
a)

void switch2(long x, long *dest) {
    long val = 0;
    
    switch (x) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
    }
    
    *dest = val;
}

a) The case labels in the switch statement body have values -1, 0, 1, 2, 4, 5,
and 7

b) The case with destination .L5 has labels O and 7. The case with destination 
.L7 has labels 2 and 4.

--------------------------------------------------------------------------------

3.31)

# a in %rdi, b in %rsi, c in %rdx, dest in %rcx

switcher:
    cmpq $7, %rdi
    ja .L2
    jmp *.L4(, %rdi, 8)
    .section .rodata
.L7:
    xorq $15, %rsi
    movq %rsi, %rdx
.L3:
    leaq 112(%rdx), %rdi
    jmp .L6
.L5:
    leaq (%rdx, %rsi), %rdi
    salq $2, %rdi
    jmp .L6
.L2:
    movq %rsi, %rdi
.L6:
    movq %rdi, (%rcx)
    ret
    
 .L4:
    .quad .L3
    .quad .L2
    .quad .L5
    .quad .L2
    .quad .L6
    .quad .L7
    .quad .L2
    .quad .L5
    
void switcher(long a, long b, long c, long *dest) {
    long val;
    
    switch (a) {
        case 5: /* Case A */
            c = b ^ 15;
            /* Fall through */
        case 0: /* Case B */
            val = c + 112;
            break;
        case 2: /* Case C */
        case 7: /* Case D */
            val = (c + b) << 2;
            break;
        case 4: /* Case E */
            val = a;
            break;
        default:
            val = b;    
    }
    
    *dest = val;
}
    
--------------------------------------------------------------------------------

3.32)

        Instruction                     State values (at beginning)
Label   PC          Instruction %rdi    %rsi    %rax    %rsp            *%rsp               Description
M1      0x400560    callq       10                      0x7fffffffe820                      Call first(10)

F1      0x400548    lea         10                      0x7fffffffe818  0x400565            Entry of first
F2      0x40054c    sub         10      11              0x7fffffffe818  0x400565            
F3      0x400550    callq       9       11              0x7fffffffe818  0x400565            Call last(9, 11)

L1      0x400540    mov         9       11              0x7fffffffe810  0x400555            Entry of last
L2      0x400543    imul        9       11      9       0x7fffffffe810  0x400555                                   
L3      0x400547    retq        9       11      99      0x7fffffffe810  0x400555            Return 99 from last

F4      0x400555    repz retz   9       11      99      0x7fffffffe818  0x400565            Return 99 from first

M2      0x400565    mov         9       11      99      0x7fffffffe820                      Resume main

--------------------------------------------------------------------------------

3.33)

%edi -> a
%sil -> b
%rdx -> u
%rcx -> v

--------------------------------------------------------------------------------

3.34)

a)

%rbx, %r15, %r14, %r13, %r12 and %rbp are callee - saved:

x -> %rbx
x + 1 -> %r15
x + 2 -> %r14
x + 3 -> %r13
x + 4 -> %r12
x + 5 -> %rbp

b)

x + 6 -> %rax -> (%rsp)
x + 7 -> %rdx -> 8(%rsp)

c)

After storing six local variables, the program has used up the supply of callee -  saved registers. It stores the remaining two local values on the stack.

--------------------------------------------------------------------------------

3.35)

# x in %rdi

rfun:
    pushq %rbx
    movq %rdi, %rbx
    movl $0, %eax
    testq %rdi, %rdi
    je .L2
    shrq $2, %rdi
    call rfun
    addq %rbx, %rax
.L2:
    popq %rbx
    ret
    
a)

%rbx stores x

b)

long rfun(unsigned long x) {
    if (x == 0) {
        return x;
    }
    
    unsigned long nx = x >> 2;
    long rv = rfun(nx);
    
    return x + rv;
}

--------------------------------------------------------------------------------